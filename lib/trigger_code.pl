use strict;

# Monitors trigger code, used by code like tv_grid and the web alarm page,
# that specifies events that trigger actions.  View, add, modify, or
# delete triggers with http://localhost:8080/bin/triggers.pl

# $Date$
# $Revision$

use vars '%triggers';           # use vars so we can use in the web server

my ($trigger_write_code_flag, $prev_triggers, $prev_script);
my $trigger_file = "$::config_parms{data_dir}/triggers.current";
my $expired_file = "$::config_parms{data_dir}/triggers.expired";
my $script_file  = "$::Code_Dirs[0]/triggers.mhp";

&::MainLoop_pre_add_hook (\&triggers_loop, 1);
&::Exit_add_hook         (\&triggers_save, 1);

sub triggers_loop { 
    &triggers_read      if $Reload and -e $trigger_file;
    $prev_triggers = &file_read($trigger_file) if $Reload and -e $trigger_file;
    $prev_script   = &file_read($script_file)  if $Reload and -e $script_file;
    &triggers_save      if new_minute 5;
    &trigger_write_code if $trigger_write_code_flag;
}	

# Read current triggers file at startup
sub triggers_read {
                                # Read trigger data
    return unless -e $trigger_file;

    my $i = 0;
    undef %triggers;

    my ($trigger, $code, $name, $type, $triggered);
    for my $record (&file_read($trigger_file), '') {
        if ($record =~ /\S/) {
            next if $record =~ /^ *#/;
            if ($record =~ /^name=(.+?)\s+type=(\S+)\s+triggered=(\d*)/) {
                $name = $1;  $type = $2; $triggered = $3;
            }
            elsif (!$trigger) {
                $trigger = $record;;
            }
            else {
                next if $record =~ /^\d+ \d+$/;  # Old trigger format ... ignore
                $code .= $record . "\n";
            }
        }
                          # Assume there is always a blank line at end of file
        elsif ($trigger) {
            trigger_set($trigger, $code, $type, $name, 1, $triggered);
            $trigger = $code = $name = $type = $triggered = '';
            $i++;
        }
    }
    print " - read $i trigger entries\n";
}

                                # Write trigger code
sub trigger_write_code {
    $trigger_write_code_flag = 0;
    my $script;
    foreach my $name (trigger_list()) {
        my ($trigger, $code, $type, $triggered, $trigger_error, $code_error) = trigger_get($name);
        next unless $trigger;
        next if $trigger_error; 
        $script .= "\n# name=$name type=$type\n";
        $script .= "if (($trigger) and &trigger_active('$name')) {\n";
        $script .= "    # FYI trigger code: $code;\n";
        $script .= "    &trigger_run('$name',1);\n}\n";
    }
    $script = "#\n#@ You shouldn't edit this file.  This file is auto-generated by mh/lib/trigger_code.pl.  If there are \n" .
              "#@ syntax errors here, you should delete this file and edit $::config_parms{data_dir}/triggers.current.  \n" . 
              "#@ This file will be recreated when Misterhouse is next started.\n#\n" . $script;
    return if $script eq $prev_script;
    $prev_script = $script;
    &file_write($script_file, $script);
                                # Replace (faster) or reload (if there was no file previously)
    if ($::Run_Members{'triggers_table'}) {
        &do_user_file("$::Code_Dirs[0]/triggers.mhp");
    }
    else {
                                # Must be done before the user code eval
        push @Nextpass_Actions, \&read_code;
    }

}

                                # Save and prune out expired triggers
sub triggers_save {
    my ($data, $data1, $data2, $i1, $i2);
    $i1 = $i2 = 0;
    $data1 = $data2 = '';
    foreach my $name (trigger_list()) {
        my ($trigger, $code, $type, $triggered) = trigger_get($name);
        next unless $trigger;
        $data  = "name=$name type=$type triggered=$triggered\n";
        $data .=  $trigger . "\n";
        $data .=  $code . ";\n";
                                # Prune it out if it is expired and > 1 week old
        if (trigger_expired($name) and ($triggers{$name}{triggered} + 60*60*24*7) < $Time) {
            $data2 .= $data . "\n";
            $i2++;
            delete $triggers{$name};
        }
        else {
            $data1 .= $data . "\n";
            $i1++;
        }
    }
    print_log "Saving triggers:  $i2 expired, $i1 saved" if $i2;
    $data1 = '#
# Note: Do NOT edit this file while mh is running (edits will be lost).
# It is used by mh/lib/trigger_code.pl to auto-generate code_dir/triggers.mhp.
# It is updated by various trigger_ functions like trigger_set.
# If Misterhouse will not start because of a code error in this file, fix the 
# error here, remove triggers.mhp, and restart Misterhouse.   
#
# Syntax is:
#   name=trigger name  type=trigger_type  triggered=triggered_time
#   trigger_clause
#     code_to_run
#     code_to_run
#
# Expired triggers will be pruned to triggers.expired a week after they expire.
#

' . $data1;
    $data2 = "# Expired on $Time_Date\n" . $data2 if $data2;
    unless ($data1 eq $prev_triggers) {
        &file_write($trigger_file, $data1);
        &logit($expired_file, $data2, 0) if $data2;
        $trigger_write_code_flag++;
    }
    $prev_triggers = $data1;
    return;
}

                                # this routine does all the heavy lifting re modifying, renaming, copying  triggers 
sub trigger_set {
    my ($trigger, $code, $type, $name, $replace, $triggered, $new_name) = @_;

    print_log "trigger_set: trigger=$trigger code=$code type=$type name=$name replace=$replace triggered=$triggered new_name=$new_name" if $Debug{'trigger'};
    return unless $trigger and $code;
    $trigger =~ s/[;\s\r\n]*$//g;  # in case trigger file was edited on windows 
    $code =~ s/[;\s\r\n]*$//g;  # So we can consistenly add ;\n when used
    $triggered = 0 unless $triggered;
    $type  = 'OneShot' unless $type;

                                # Give it a name if missing 
    $name = time_date_stamp(12) unless $name;

                                # Find a uniq name if copying, should also handle renaming if new name is taken 
    if (exists $triggers{$name} and $replace) {
        print_log "trigger $name already exists, modifying";
    }
    elsif (exists $triggers{$name}) {
        $name =~ s/ \d+$//;
        my $i = 2;
        while (exists $triggers{"$name $i"}) { $i++; }
        print_log "trigger $name already exists, adding '$i' to name";
        $name = "$name $i";
    }
    print_log "trigger_set: trigger=$trigger code=$code type=$type name=$name replace=$replace triggered=$triggered new_name=$new_name" if $Debug{'trigger'};
	
                                # Flag an error if trigger is bad, can't test code here without running it 
    eval $trigger;
    if ($@) {
        $triggers{$name}{'trigger_error'} = $@;
        &print_log("Error: trigger '$name' has an error, disabling");
        &print_log("  Code = $trigger");
        &print_log("  Result = $@");
    } else {
        delete $triggers{$name}{'trigger_error'};
    }

    $triggers{$name}{trigger} = $trigger;
    $triggers{$name}{code}    = $code;
    $triggers{$name}{triggered} = $triggered;
    $triggers{$name}{type}  = $type;

    if ($new_name and $new_name ne $name) {
        $triggers{$new_name} = $triggers{$name};
        delete $triggers{$name};
    }

    $trigger_write_code_flag++;
    return;
}

sub trigger_get {
    my $name = shift;
    return 0 unless exists $triggers{$name};
    return 1 unless wantarray;
    return $triggers{$name}{trigger}, $triggers{$name}{code}, $triggers{$name}{type}, $triggers{$name}{triggered}, 
      $triggers{$name}{trigger_error}, $triggers{$name}{code_error};
}


sub trigger_delete {
    my $name = shift;
    return unless exists $triggers{$name};
    delete $triggers{$name};
    $trigger_write_code_flag++;
    return;
}

sub trigger_copy {
    my $name      = shift;
    my $trigger   = $triggers{$name}{trigger};
    my $code      = $triggers{$name}{code};
    my $type      = $triggers{$name}{type};
    my $replace   = 0;
    my $triggered = 0;
    trigger_set($trigger, $code, $type, $name, $replace, $triggered);
    return;
}

sub trigger_rename {
    my ($name, $new_name) = @_;
    return unless exists $triggers{$name};
    my $trigger   = $triggers{$name}{trigger};
    my $code      = $triggers{$name}{code};
    my $type      = $triggers{$name}{type};
    my $replace   = 1;
    my $triggered = $triggers{$name}{triggerd};
    trigger_set($trigger, $code, $type, $name, $replace, $triggered, $new_name);
    return;
}

sub trigger_set_trigger {
    my $name      = shift;
    return unless exists $triggers{$name};
    my $trigger   = shift;
    my $code      = $triggers{$name}{code};
    my $type      = $triggers{$name}{type};
    my $replace   = 1;
    my $triggered = $triggers{$name}{triggered};
    trigger_set($trigger, $code, $type, $name, $replace, $triggered);
    return;
}

sub trigger_set_code {
    my $name      = shift;
    return unless exists $triggers{$name};
    my $trigger   = $triggers{$name}{trigger};
    my $code      = shift;
    my $type      = $triggers{$name}{type};
    my $replace   = 1;
    my $triggered = $triggers{$name}{triggered};
    trigger_set($trigger, $code, $type, $name, $replace, $triggered);
    return;
}

sub trigger_set_type {
    my $name      = shift;
    return unless exists $triggers{$name};
    my $trigger   = $triggers{$name}{trigger};
    my $code      = $triggers{$name}{code};
    my $type      = shift;
    my $replace   = 1;
    my $triggered = $triggers{$name}{triggerd};
    trigger_set($trigger, $code, $type, $name, $replace, $triggered);
    return;
}

sub trigger_run {
    my ($name,$expire) = @_;
    if (!exists $triggers{$name}) {
    	&print_log("Trigger '$name' does not exist");
    	return;
    }
    &trigger_expire($name) if $expire;
    my ($trigger, $code, $type, $triggered) = trigger_get($name);
    &print_log ("Running trigger code for: $name") if $Debug{trigger};
    eval $code;
    &print_log ("Finished running trigger code for: $name") if $Debug{trigger};
    if ($@) {
	    &print_log("Error: trigger '$name' failed to run cleanly");
	    &print_log("  Code = $code");
	    &print_log("  Result = $@");
	    # At this point we could opt to disable the trigger
	    # but it is likely more useful to have a repeating error message
	    # to let the user know that something is wrong
	    # The following hash entry allows us to show the error in the web interface 
	    $triggers{$name}{code_error} = $@;
    } else {
	    delete $triggers{$name}{code_error};
    }
    return;
}


sub trigger_list {
    return sort keys %triggers;
}

sub trigger_active {
    my $name = shift;
#   print "db n=$name t=$triggers{$name}{type} e=!$triggers{$name}{triggered}\n";
    return (exists $triggers{$name} and
        ($triggers{$name}{type} eq 'NoExpire' or $triggers{$name}{type} eq 'OneShot') and 
        (not exists $triggers{$name}{'trigger_error'})
    );
}

sub trigger_expired {
    my $name = shift;
    return (exists $triggers{$name} and $triggers{$name}{type} eq 'Expired');
}

sub trigger_expire {
    my $name = shift;
    $triggers{$name}{triggered} = $Time;
    return unless exists $triggers{$name} and $triggers{$name}{type} eq 'OneShot';
#   print "db setting name=$name expire_time=$Time\n";
    $triggers{$name}{type}      = 'Expired';
    return;
}

1;
