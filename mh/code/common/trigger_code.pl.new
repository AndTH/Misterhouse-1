# Category = MisterHouse

#@ Monitors trigger code, used by code like tv_grid and the web alarm page,
#@ that specifies events that trigger actions.  View, add, modify, or
#@ delete triggers <a href=/SUB;trigger_html>here</a>.

use vars '@trigger_data';      # keep this until everyone upgrades 
my %triggers;

$trigger_code_v = new Voice_Cmd '[Read,Save] the triggers file';
$trigger_code_v-> set_info('Read from or save to the data_dir/triggers.current file');

&Exit_add_hook(\&triggers_save) if $Reload;
&triggers_save(1) if new_minute 5 or ('Save' eq said $trigger_code_v);
&triggers_read(0) if $Startup     or ('Read' eq said $trigger_code_v);
&triggers_read(1) if new_second 10;

# Read either current triggers file (at startup) or new entries periodicaly
sub triggers_read {
    my ($new) = @_;
                                # Read trigger data
    my $trigger_file = "$config_parms{data_dir}/triggers";
    $trigger_file .= ($new) ? '.new' : '.current';
    return unless -e $trigger_file;

    my $i = 0;
    undef %triggers unless $new;

    select undef, undef, undef, .1;  # Make sure file is saved ok
    my ($trigger, $code, $limit, $count, $name);
    for my $record (&file_read($trigger_file), '') {
        if ($record =~ /\S/) {
            next if $record =~ /^ *#/;
            if (($limit, $count, $name) = $record =~ /^\s*(\d+)\s*(\d*)\s*(.*)\s*$/) {
            }
            elsif (!$trigger) {
                $trigger = $record;;
            }
            else {
                $code .= $record . "\n";
            }
        }
        elsif ($trigger) {
            trigger_set($trigger, $code, $limit, $count, $name);
            $trigger = $code = $limit = $count = $name = '';
            $i++;
        }
    }
    if ($trigger) {         # In case there is no blank line at end of file 
        trigger_set($trigger, $code, $limit, $count, $name);
        $i++;
    }
    print_log "Read $i " . ($new ? "new " : "") . "trigger entries";
    unlink $trigger_file if $new;
    &triggers_save;
    &trigger_write_code;
}

                                # Write trigger code
my $prev_script;
sub trigger_write_code {
    my $script;
    foreach my $name (trigger_list()) {
        my ($trigger, $code, $limit, $count) = trigger_get($name);
        $script .= "\n# limit=$limit  count=$count  name=$name\n";
        $script .= "if (($trigger) and &trigger_active('$name')) {\n";
        $script .= "    $code";
        $script .= "    &trigger_increment('$name');\n}\n";
    }
    return if $script eq $prev_script; 
    $prev_script = $script; 
    $script = "#\n# Do NOT edit.  This file is auto-generated by mh/code/common/trigger_code.pl\n" . 
              "# and reflects the data in data_dir/triggers.current\n#\n" . $script;
    &file_write("$config_parms{code_dir}/triggers.pl", $script);
                                # Replace (faster) or reload (if there was no file previously)
    print "dbx1 checking: $Run_Members{'triggers'}\n";
    if ($Run_Members{'triggers'}) {
    print "dbx2 checking: $Run_Members{'triggers'}\n";
        &do_user_file("$config_parms{code_dir}/triggers.pl");
    }
    else {
                                # Must be done before the user code eval
        push @Nextpass_Actions, \&read_code;
    }

}

                                # Save and prune out expired triggers
my $prev_data1;
sub triggers_save {
    my ($data, $data1, $data2, $i1, $i2);
    $i1 = $i2 = 0;
    $data1 = $data2 = '';
    foreach my $name (trigger_list()) {
        my ($trigger, $code, $limit, $count) = trigger_get($name);
        $data  =  $trigger . "\n";
        $data .=  $code;
        $data .= "$limit $count $name\n";
        if (trigger_active($name)) {
            $data1 .= $data . "\n";
            $i1++;
        }
        else {
            $data2 .= $data . "\n";
            $i2++;
            trigger_delete($name);
        }
    }
    print_log "Saving triggers:  $i2 expired, $i1 saved" if $i2;
    $data1 = '#
# This file is used by mh/code/common/trigger_code.pl to auto-generate code_dir/triggers.pl.
# Normally this file is updated by creating entries into 
# triggers.new, which is read and deleted every 10 seconds.
# If you manually edit this file, run "Read the triggers file"
# before mh re-saves this file (every 5 minutes).  
# Syntax for both triggers.current and triggers.new is:
#
#  trigger_clause
#    code_to_run
#    code_to_run
#  count_times_to_run  count_times_it_has_run  trigger_name 
#
# The count* fields are optional (default to running just once)
# Set count_times_to_run to 0 to run forever 
# trigger_name is optional (defaults to a date and time stamp)
#

' . $data1;
    $data2 = "# Expired on $Time_Date\n" . $data2 if $data2;
    &file_write("$config_parms{data_dir}/triggers.current", $data1) unless $data1 eq $prev_data1;
    $prev_data1 = $data1; 
    &logit("$config_parms{data_dir}/triggers.expired", $data2, 0) if $data2;
}

sub trigger_set {
    my ($trigger, $code, $limit, $count, $name) = @_;

    return unless $trigger and $code; 
    $name = time_date_stamp(6) . ' ' . get_tickcount unless $name;
    if (trigger_get($name)) {
        print_log "trigger $name already exists, modifying";
    }
    $limit = 1 unless $limit =~ /^\d+$/;
    $count = 0 unless $count =~ /^\d+$/;
    $triggers{$name}{trigger} = $trigger; 
    $triggers{$name}{code} = $code; 
    $triggers{$name}{limit} = $limit; 
    $triggers{$name}{count} = $count;
    &triggers_save(1);
}

sub trigger_get {
    my $name = shift; 
    return $triggers{$name}{'trigger'}, $triggers{$name}{'code'}, $triggers{$name}{'limit'}, $triggers{$name}{'count'};
}

sub trigger_delete {
    my $name = shift; 
    delete $triggers{$name};
    &triggers_save(1);
}

sub trigger_list {
    return sort keys %triggers;
}

sub trigger_active {
    my $name = shift; 
    my ($trigger, $code, $limit, $count) = trigger_get($name);
    return 1 if $limit == 0 or $count < $limit; 
    return 0;
}

sub trigger_increment {
    my $name = shift; 
    $triggers{$name}{count}++; 
    &triggers_save(1);
    return;
}

$Included_HTML{MisterHouse} = '<!--#include code="&trigger_html"-->'  if $Reload; 

sub trigger_html {
    my $data = 'Triggers:<p>'; 
    foreach my $name (trigger_list()) {
        my ($trigger, $code, $limit, $count) = trigger_get($name);
        $data .= "$name, $trigger, $code, $limit, $count<p>\n";
    }
    return $data; 
}
