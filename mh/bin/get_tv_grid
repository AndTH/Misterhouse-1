#!/usr/bin/perl
#  Last change Time-stamp: <2001-12-08 23:14:28 winter>
#---------------------------------------------------------------------------
#  File:
#      get_tv_grid
#  Description:
#      See help text below
#  Author:
#      Bruce Winter    bruce@misterhouse.net   http://misterhouse.net
#  Latest version:
#      http://misterhouse.net/mh/bin
#  Change log:
#    04/25/98  Created.
#
#---------------------------------------------------------------------------
use strict;
my($Pgm_Path, $Pgm_Name, $Version);
BEGIN {
    ($Version) = q$Revision$ =~ /: (\S+)/; # Note: revision number is auto-updated by cvs
    ($Pgm_Path, $Pgm_Name) = $0 =~ /(.*)[\\\/](.*)\.?/;
    ($Pgm_Name) = $0 =~ /([^.]+)/, $Pgm_Path = '.' unless $Pgm_Name;
    eval "use lib '$Pgm_Path/../lib', '$Pgm_Path/../lib/site'"; # So perl2exe works
}
my %parms;
use Getopt::Long;
if (!&GetOptions(\%parms, "h", "help", "infile=s", "outfile=s", "outdir=s", "reget", "redo", "db=s", "name=s",
                 "keep=s", "skip=s", "channel_max=s", "zip:s", "provider:s", "debug", "label=s", "keep_old",
                 "mail_to=s", "mail_server=s", "mail_baseref=s",
                 "days=s", "day=s", "hour=s") or @ARGV or
    ($parms{h} or $parms{help})) {
    print<<eof;
$Pgm_Name gets a TV grid/schedule from the web (zap2it.com) and changes so
it to be used by the MisterHouse program to create VCR and TV event reminders.
Creates a DBM for use by get_tv_info.
  Version: $Version
  Usage:
   $Pgm_Name [options]
    -h        => This help text
    -help     => This help text
    -db   xyz      => xyz is the database (tv, sat, cable, default tv)
    -name xyz      => xyz is the name of the service (TV, Dish Network,
                      Cable, etc) default is TV
    -zip xyz      => xyz is your zip code
    -provider xyz => xyz is your TV provider ID.  See note below
    -day xyz      => xyz is the day  to get/filter.  Default is today.
    -hour xyz     => xyz is the hour to get/filter.  Default is 6pm.  Can also
                     be 'all' to get all hours.
    -days xyz     => xyz is the number of days to get/filter, starting 
                     with -day.
    -channel_max xyz  => Channels above xyz will be dropped.  Default is 999.
    -keep    xyz  => xyz is a list of channels to keep.
    -skip    xyz  => xyz is a list of channels to skip.
    -infile  xyz  => xyz is  original input file.   Default is 
                     web/tv/download/day_hour.html.  If this file is missing
                     or old, a new file will be retrieved from the web.
    -outfile xyz  => xyz the filtered output file. 
                     Default is -outdir/day_hour.html
    -outdir  xyz  => xyz the directory the outfiles will be put in.
                     Default is mh.ini parm html_dir/{db}
    -label xyz    => Use xyz as the link lable.  Default is "VCR".  
                     To disable, set to none (-label none).
    -reget        => Re-read  the web page, even if a recent file it
                     already exists.
    -redo         => Re-write -outfile xyz, even if it already exists.
    -keep_old     => Do NOT delete data from the DBM that is one month older 
                     than todays date
    -debug        => turn on debug info

    -mail_to      xyz => Will email the charts to xyz
    -mail_server  xyz => xyz is the SMTP host.  Default is localhost
    -mail_baseref xyz => xyz is the http address of your mh server.  Needed if
                         you want to control mh from the emailed web page
  Example:
    $Pgm_Name -day 25 -hour 4pm -outfile my_tv.html
    $Pgm_Name -days 7 -hour all -keep "2,4,8,12,33"
    $Pgm_Name -email bruce\@misterhouse.net -mail_baseref misterhouse.net:8080

  Note on finding your provider ID:
   Enter your zip code at http://tvlistings.zap2it.com/
   View the html source and pick the number from value='nnnnnn'
   by doing a string search for you provider.  For example:
      <OPTION value="255248">Charter Communications - Rochester</OPTION>

eof
  exit;
}
                                # Globals
my (@days, @hours, $infile, $outfile, %DBM, %DBM2, %channels_skip, %channels_keep, $channel_data);
my ($url, $ua, $cookies, $req_get1, $req_get2, $req_post, $logged_in);

use vars '%config_parms';       # Not a my, as it is called from handy_net_utils for sent
&setup;
for my $day_data (@days) {
    my ($down, $dow, $day, $month, $year, $day_time) = split(' ', $day_data);
    for my $hour (@hours) {
        print "Checking day=$day hour=$hour\n" if $parms{debug};
        $outfile = "$parms{outdir}/${day}_$hour.html" unless $parms{outfile};
        if ($parms{redo} or !(-e $outfile) or (8 < -M $outfile) or (4000 > -s $outfile)) {
            &get_html($hour, $day, $month, $year);
            &filter_html($hour, $down, $dow, $day, $month, $year, $day_time);
        }
        if ($day == (localtime(time))[3] and $hour >  17 and $hour <= 20) {
            use File::Copy;
            copy($outfile, "$parms{outdir}/index.html");
            if ($parms{mail_to}) {
                &mail_file($parms{mail_to}, $parms{mail_server}, $outfile, "$parms{name} Schedule for $dow, $month/$day/$year");
            }
        }
    }
    &delete_old_data unless $parms{keep_old};
}
dbmclose %DBM;
dbmclose %DBM2;

sub get_html {
    my ($hour, $day, $month, $year) = @_;
    $infile = $parms{infile};
    $infile = "$parms{outdir}/download/${day}_$hour.html" unless $infile;
                                # File must exist, be younger than a week old, and have > 1k bytes
    if ((-e $infile) and (8 > -M $infile) and (4000 < -s $infile) and !$parms{reget}) {
        print "Reusing file: $infile\n";
    }
    else {
        &login unless $logged_in;
        print "Requesting data for hour=$hour day=$day month=$month year=$year .";
        my $hours = ($parms{hour} eq 'all_by_3') ? 3 : 4;
        $req_post->content("displayType=Grid&duration=$hours&startDay=$month/$day/$year&startTime=$hour&category=0&station=0&goButton=GO");
        print " .";
        print "Sending:\n" . $req_post->as_string . $cookies->as_string . "\n" if $parms{debug};
        my $res = $ua->request($req_post);
        print " .";
                                # Gotta request again, as first grid does not have all the channels :(
        print "Sending:\n" . $req_get2->as_string . $cookies->as_string . "\n" if $parms{debug};
        $res = $ua->request($req_get2, $infile);
        print " .\n";
        unless ($res->is_success) {
            print "  Error: " . $res->status_line . "\n";
        }
    }
}

                                # Get the ASPSESSION cookie
sub login {
    print "Getting the session cookie ...\n";
    print "Sending:\n" . $req_get1->as_string . $cookies->as_string . "\n" if $parms{debug};
    my $res = $ua->simple_request($req_get1);
    $logged_in++;
}

sub filter_html {
    my ($hour, $down, $dow, $day, $month, $year, $day_time) = @_;
    my $min = $hour*60;
    open (IN,   "$infile")  || die "Error, could not open file $infile: $!\n";
    open (OUT, ">$outfile") || die "Error, could not open file $outfile: $!\n";
    print "Filtering $infile to $outfile\n" if $parms{debug};
    print OUT<<eof;
<HTML>
<HEAD>
<TITLE>$parms{name} Schedule for $dow, $month/$day.$year</TITLE>
</HEAD>
<body bgcolor=gray>
eof
    my ($record, $record_prev, $script, $script_flag, $data_flag, $count1, $count2, $count3);
    my ($channel_number, $channel_name, $pgm_name, $pgm_desc, $min_start, $min_end, $min_pgm);

    $count1 = $count2 = $count3 = 0;
    while ($record = <IN>) {
        $count1++;
                                # Pull out javascript stuff
        $script_flag = 1 if /<script language=/i;
        if ($script_flag) {
#           $_ =~ s|([a-z]+\.asp\?)|http://listings.clicktv.com/$1|g;
            $script .= $_;
        }
        $script_flag = 0 if /<\/script/i;

                                # Look for start of good stuff ... looks like this
#<!--sp_GetGridInfo 100128400, '10/24/2001 1:00:00 AM', '10/24/2001 5:00:00 AM', 0, 0, 3, '',''--><table BORDER="1" BGCOLOR="#FFFFFF" CELLPADDING="2" CELLSPACING="1" WIDTH="100%">
        if (!$data_flag and $record =~ /GetGridInfo /i) {
            print "Found start of $parms{name} grid\n" if $parms{debug};
            $data_flag = 1;
            &make_index($hour, $down, $day, $day_time);
            print OUT $record;
            next;
        }
        
                                # data_flag = 1 -> channel data
                                # data_flag = 2 -> bottom data
        next unless $data_flag;
        if ($record =~ / END GRID TABLE / and $data_flag = 1) {
            print OUT "</table>\n";
            $data_flag = 2;
        }

                                # New channel row
        if ($channel_number and $record =~ /<tr>/) {
            $channel_data = '';
        }
                                # Print out previous channel, unless we want to skip it  
        if ($channel_number and $record =~ /<\/tr>/) {
            print OUT $channel_data unless
                ($parms{keep} and !$channels_keep{$channel_number}) or
                ($parms{skip} and  $channels_skip{$channel_number});
            $channel_data = '';
        }

        $count2++;
                                # Point to local gifs
        $record =~ s|images/([^/]+?.gif)|/tv/$1|g;
        $record =~ s|/?images.+?/([^/]+?.gif)|/tv/$1|g;
#       print "db gif record=$record\n" if $record =~ /\.gif/;
                                # Discard channel .jpgs
#       $record =~ s!<img .+?\.(jpg|gif)[^>]+?>!!g;
                                # Make local copy of channel .jpgs
        if ($record =~ s!http://tvlistings\d?.zap2it.com/tms_network_logos/([^/]*\.(jpg|gif))!/tv/logos/$1!) {
            unless (-f "$parms{outdir}/logos/$1") {
                my $req = new HTTP::Request('GET',
                                            "http://tvlistings.zap2it.com/tms_network_logos/$1");
                my $res = $ua->request($req, "$parms{outdir}/logos/$1");
                unless ($res->is_success) {
                    print "  Error: " . $res->status_line . "\n";
                }
            }
        }


                                # Point to remote tv discriptions
                                #  <a href="listings_redirect.asp?station_num=10715">
                                #  <form method="post" action="listings_redirect.asp"><TD height=3 width = "100%" align=center> 
        $record =~ s|\"([_a-z]+\.asp\??)|\"http://tvlistings.zap2it.com/$1|g;


                                # Find channel number and name
                                #  ...station_num=10715">2<br><nobr>KTCA</nobr>
        if ($record =~ /\> *(\d+) *<br><nobr>(\S*?)\</i) {
            $channel_number = $1; $channel_name = $2;
            print "Found channel: $channel_number => $channel_name\n" if $parms{debug};
            $min_start = $min;
            $min_end = '';
            last if $channel_number > $parms{channel_max};
        }

#       last if $record =~ / END GRID TABLE /;


        unless (($parms{keep} and !$channels_keep{$channel_number}) or
                ($parms{skip} and  $channels_skip{$channel_number}) ) {

# ...progdetails.asp?prog_id=1675831&series_id=553685">Scientific American Frontiers: <i>The Gene Hunters</i></a></font>
#   <font face="arial,helvetica" size="-2"></b>   TVG Geneticists Jim Watson ...
#			</font>

            if ($record =~ /colspan="?(\d+)"?/) {
                $min_start = $min_end if $min_end;
                $min_pgm = 30 * $1;
                $min_end = $min_start + $min_pgm;
            }

            if ($record =~ /progdetails.+?>(.+?)<\/a.+?<\/b> *(.+)/) {
                ($pgm_name, $pgm_desc) = ($1, $2);
                if ($pgm_name) {
                    $count3++;
                                # Clean up the program description
                    $pgm_name =~ s/\<.+?\>//g; # Drop extra HTML directives (e.g. font)
                    $pgm_desc =~ s/\<.+?\>//g; # Drop extra HTML directives (e.g. font)
                    $pgm_desc =~ s/  / /g;     # Drop extra spaces
                    my $pgm_name_html = $pgm_name;
                    $pgm_name_html =~ tr/ /_/;
                                # Set program times/dates
                    my $time_start = &min_to_hour($min_start);
                    my $time_end   = &min_to_hour($min_end);
                    my $pgm_date = "$month/$day";
                    print "db $pgm_name, $min_pgm, $min_start, $min_end, $time_start, $time_end, $pgm_date\n" if $parms{debug};
                                # Insert the mh link
                    my $vcr_ref =
                        "<a href='/SET:last_spoken?\$tv_grid?channel_${channel_number}_from_${time_start}" .
                            "_to_${time_end}_on_${pgm_date}_for_${pgm_name_html}'>$parms{label}</a>";
                    $record =~ s|<a href=|$vcr_ref for <a href=| unless lc $parms{label} eq 'none';
                                # Store the data in the DBM
                    my $db_key = join($;, $channel_number, $pgm_date, $time_start);
                    my $db_data= join($;, $time_end, $pgm_name, $pgm_desc);
                    $DBM{$db_key} = $db_data;
                    $DBM2{$channel_number} = $channel_name;
                    print "db key=$db_key\n  data=$db_data.\n" if $parms{debug};
                }
            }
        }

        if ($data_flag == 1) {
            $channel_data .= $record;
        }
        elsif ($data_flag == 2) {
            print OUT $record;
        }
    }
    print "$count1 records with $count2 grid rows were read.  $count3 programs stored.\n";
    close IN;
    close OUT;
}
                                # Create the index table, for the next 2 weeks, and for other hours in this day
sub make_index {
    my ($hour, $down, $day, $day_time) = @_;
    print OUT "<center>\n<table border=1 width=100%>\n<tr>\n<td align=left>\n";		### DW: remove bgcolors
    print OUT "<font face=arial size=+1 color=white> $parms{name} Listings</td><td align=right>";
    print OUT "<FORM>";
    print OUT "<SELECT NAME=url onchange=window.open(this.options[this.selectedIndex].value,'_top')>";
    my $dow_start = -$down - 7;
    my $dow_stop  = $dow_start + 20;
    for my $count ($dow_start .. $dow_stop) {
        my ($dow2n, $dow2, $day2, $month2, $year2) = &days_from_now($day_time, $count);
        print OUT "<option value='/" . $parms{db} . "/${day2}_$hour.html'";
        if ($day2 == $day)  {
          print OUT " Selected ";
        }
        print OUT ">$dow2, $month2/$day2\n";
    }
    print OUT "</select>\n";
    print OUT "<SELECT NAME=tvtime onchange=window.open(this.options[this.selectedIndex].value,'_top')>";

#   for my $hour2 (2, 6, 10, 14, 18, 22) {
    for my $hour2 (@hours) {
        my $hour2_ampm;
 
        if ($hour2 == 12) {
            $hour2_ampm = "12 pm";
        }
        elsif ($hour2 > 12) {
            $hour2_ampm = $hour2 - 12 . " pm";
        }
        elsif ($hour2 == 0) {
            $hour2_ampm = "12 am";
        }
        else {
            $hour2_ampm = $hour2 + 0 . " am";
        }
#       $hour2_24 = '0' . $hour2 if $hour2 < 10;

 


         print OUT "<option value='/" . $parms{db} . "/${day}_${hour2}.html'";
         if ($hour2 == $hour)  {
           print OUT " Selected ";
         }

         print OUT ">$hour2_ampm\n";

#        print OUT "<td align=center bgcolor=white><a href=/tv/${day}_${hour2}.html>$hour2_ampm</a><td>\n";
    }
    print OUT "</select></td>\n";
    print OUT "</tr>\n</form></table></center>\n";
}
                                # Delete data from 4 weeks ago
sub delete_old_data {
    my ($down, $down, $day, $month) = &days_from_now(time, -28);
    my $pgm_date = "$month/$day";
    print "Deleting old data from 4 weeks ago: $pgm_date ...";
    my @channels = keys %DBM2;
    for my $channel_number (@channels) {
        for my $hour (00 .. 23) {
            for my $min ('00', '30') {
                my $db_key = join($;, $channel_number, $pgm_date, "$hour:$min");
#               print "deleting $db_key\n" if $parms{debug};
                delete $DBM{$db_key};
            }
        }
    }
    print " data deleted.\n";
}
sub min_to_hour {
    my ($min) = @_;
    my $hour = int($min / 60);
    $min = $min - $hour * 60;
    return sprintf("%d:%02d", $hour, $min);
}
sub days_from_now {
    my ($day_time, $days) = @_;
#   $day_time = time if $parms{day}; # Need to do a string to time thing here.
    my $day_time2 = $day_time + $days * 60 * 60 * 24;
    my ($day, $month, $year, $down) = (localtime($day_time2))[3,4,5,6];
    my $dow = (qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday))[$down];
#   $month= (January,February,March,April,May,June,July,August,Septermber,October,November,December)[$month];
    $month++;
    $year += 1900;
    $day = sprintf("%02d", $day);
    return ($down, $dow, $day, $month, $year, $day_time2);
}
                                # Email default page
sub mail_file {
    my ($mailto, $mailserver, $file, $subject) = @_;
    $mailserver = 'localhost' unless $mailserver;
    $parms{mail_baseref} = 'localhost' unless $parms{mail_baseref};
    print "$Pgm_Name is now mailing $file to $mailto\n";
    my $date = localtime;
                                # Modify the html so it has a BASE HREF and the links work in a mail reader
#   my $html = &file_read($file);
#   $html =~ s|<HEAD>|<HEAD>\n<BASE HREF="http://$parms{mail_baseref}">|i;

                                # From handy_net_utilities
    &net_mail_send(subject => $subject,
                   server  => $mailserver,
                   from    => $Pgm_Name,
                   to      => $mailto,
                   baseref => $parms{mail_baseref},
#                  filename=> 'tv_grid.html',
#                  text    => $html,
                   file    => $file,
                   mime    => 1);

    return;
}

sub setup {
    
    require 'handy_utilities.pl';      # For read_mh_opts 
    require 'handy_net_utilities.pl';  # For net_mail_send
    &main::read_mh_opts(\%config_parms, $Pgm_Path);
#   $parms{userid} = '%247A%247B%2489%247A' unless $parms{userid};

    $parms{db}       = 'tv'  unless $parms{db};
    $parms{outdir}   ="$config_parms{html_dir}/$parms{db}"     unless $parms{outdir};
    $parms{zip}      = $config_parms{zip_code}                 unless $parms{zip};
    $parms{provider} = $config_parms{$parms{db} . '_provider'} unless $parms{provider};
    $parms{hour}     = $config_parms{$parms{db} . '_hours'}    unless $parms{hour};
    $parms{label}    = $config_parms{$parms{db} . '_label'}    unless $parms{label};
    $parms{skip}     = $config_parms{$parms{db} . '_channels_skip'}  unless $parms{skip};
    $parms{keep}     = $config_parms{$parms{db} . '_channels_keep'}  unless $parms{keep};

    $parms{name}        = 'TV'     unless $parms{name};
    $parms{zip}         = '55901'  unless $parms{zip};
    $parms{provider}    = '255248' unless $parms{provider};
    $parms{channel_max} = '999'    unless $parms{channel_max};
    $parms{label} = "VCR" unless $parms{label};  # This can also be an image link
#   $parms{label} = qq[<img src="/tv/vcr.jpg">] unless $parms{label};
    $parms{days}  = 1 unless $parms{days};
    $parms{redo}  = 1 if $parms{reget};

    %channels_keep = map{$_, 1} split(',', $parms{keep}) if $parms{keep};
    %channels_skip = map{$_, 1} split(',', $parms{skip}) if $parms{skip};

    for my $count (0 .. $parms{days}-1) {
        my @day_data = &days_from_now(time, $count);
        push(@days, "@day_data"); # $dow $month $day $year");
    }
    $parms{hour} = '6pm' unless $parms{hour};
    if (lc($parms{hour}) eq 'all') {
        @hours = qw(02 06 10 14 18 22);
    }
    elsif (lc($parms{hour}) eq 'all_by_3') {
        @hours = qw(02 05 08 11 14 17 20 23);
    }
    elsif (1 < (@hours = split(',', $parms{hour}))) {
        for (@hours) {
            $_ = sprintf("%02d", $_);         # force hour to be  zero padded
#           print "$_/n";
        }
    }

    elsif (1 < (@hours = split(',', $parms{hour}))) {
    }
    else {
        my ($hour, $am_pm) = $parms{hour} =~ /(\d+) *(\S*)/;
        $hour += 12 unless lc($am_pm) eq 'am' or $hour == 12;
        @hours = (sprintf("%02d", $hour));
    }
    my $dbm_file  = "$config_parms{data_dir}/$parms{db}_programs.dbm";
    my $dbm_file2 = "$config_parms{data_dir}/$parms{db}_channels.dbm";

    print "Files will be stored to $parms{outdir}\n";
    print "Tieing to $dbm_file\n";        
    use Fcntl;
    use DB_File;
    tie (%DBM,  'DB_File',  $dbm_file,  O_RDWR|O_CREAT, 0666) or print "\nError, can not open dbm file $dbm_file: $!";
    tie (%DBM2, 'DB_File',  $dbm_file2, O_RDWR|O_CREAT, 0666) or print "\nError, can not open dbm file $dbm_file2: $!";


    mkdir $parms{outdir}, 0777 unless -d $parms{outdir};
    mkdir "$parms{outdir}/logos", 0777 unless -d "$parms{outdir}/logos";
    mkdir "$parms{outdir}/download", 0777 unless -d "$parms{outdir}/download";

    use LWP::Simple;
    use LWP::UserAgent;
    use HTTP::Cookies;
    use HTTP::Request::Common;
    
    $url      = 'http://tvlistings.zap2it.com/';
    $ua       = LWP::UserAgent->new;
    $cookies  = HTTP::Cookies->new();
    $req_get1 = HTTP::Request->new(GET  => $url . 'gridall.asp');
    $req_post = HTTP::Request->new(POST => $url . 'listings_redirect.asp');
    $req_get2 = HTTP::Request->new(GET  => $url . 'listings_redirect.asp?spp=0');

    $req_post-> content_type('application/x-www-form-urlencoded');

    $cookies -> set_cookie(0,                           # $version,
                           'TVListings',                # $key,
                           "ZipCode=$parms{zip}&ProviderID=$parms{provider}&vstr%5Fid=",
                           '/',                         # $path,
                           'tvlistings.zap2it.com');   # $domain,
    $ua -> cookie_jar($cookies); 

}

#
# $Log$
# Revision 1.38  2001/12/16 21:48:40  winter
# - 2.62 release
#
# Revision 1.37  2001/11/18 22:51:42  winter
# - 2.61 release
#
# Revision 1.36  2001/10/21 01:22:31  winter
# - 2.60 release
#
# Revision 1.35  2001/05/06 21:07:25  winter
# - 2.51 release
#
# Revision 1.34  2001/04/15 16:17:20  winter
# - 2.49 release
#
# Revision 1.33  2001/02/24 23:18:40  winter
# - 2.45 release
#
# Revision 1.32  2001/02/04 20:31:30  winter
# - 2.43 release
#
# Revision 1.31  2000/12/21 18:54:14  winter
# - 2.38 release
#
# Revision 1.30  2000/12/03 19:38:50  winter
# - 2.36 release
#
# Revision 1.29  2000/11/12 21:01:02  winter
# - 2.34 release
#
# Revision 1.28  2000/08/19 01:20:42  winter
# - 2.27 release
#
# Revision 1.27  2000/08/06 21:56:43  winter
# - See 2.24 release notes.
#
# Revision 1.26  2000/06/24 22:10:54  winter
# - 2.22 release.  Changes to read_table, tk_*, tie_* functions, and hook_ code
#
# Revision 1.25  2000/04/09 18:03:19  winter
# - 2.13 release
#
# Revision 1.24  2000/03/10 04:09:01  winter
# - Add Ibutton support and more web changes
#
# Revision 1.23  2000/02/12 05:33:34  winter
# - commit lots of changes, in preperation for mh release 2.0
#
# Revision 1.22  2000/01/27 13:22:33  winter
# - update version number
#
# Revision 1.21  2000/01/02 23:40:16  winter
# - added dropbox code for index
#
# Revision 1.20  1999/11/17 04:46:32  winter
# *** empty log message ***
#
# Revision 1.19  1999/11/17 04:30:51  winter
# - allow -hour option to bye all_by_3 or explicit list
#
# Revision 1.18  1999/10/02 22:39:55  winter
# - fix use lib eval
#
# Revision 1.17  1999/10/01 00:20:23  winter
# - delete explicit use lib.
#
# Revision 1.16  1999/09/27 03:12:51  winter
# - add mailto option.  Fix detail.asp links to point back to clicktv.
#
# Revision 1.15  1999/09/12 16:16:00  winter
# - fixed $Version bug
#
# Revision 1.14  1999/09/02 13:45:01  winter
# *** empty log message ***
#
# Revision 1.13  1999/09/02 13:40:36  winter
# - Change to new clicktv.com format.  Add delete_old_data, keep_old.
#
# Revision 1.12  1999/07/21 21:08:41  winter
# - fix typo in pgm_name_html.  Increase -s $outfile size check
#
# Revision 1.11  1999/07/05 22:30:15  winter
# - added DBM store.  added -label.  Fix/keep javascript code.
#
# Revision 1.10  1999/07/05 16:49:09  winter
# - added DBM saves.
#
# Revision 1.9  1999/06/20 22:30:16  winter
# - use last_spoken on SET
#
# Revision 1.8  1999/03/21 17:38:31  winter
# - email change
#
# Revision 1.7  1999/03/12 04:35:27  winter
# - fix time/date check
#
# Revision 1.6  1999/02/08 00:37:54  winter
# - add -redo.  Only re-filter if needed, or -redo.
#
# Revision 1.5  1999/02/04 14:35:24  winter
# - aplit on day_data not day
#
# Revision 1.4  1999/02/01 00:09:36  winter
# - use lib, so mh libs are found
#
# Revision 1.3  1999/01/30 21:47:08  winter
# - add an index.
#
# Revision 1.2  1999/01/24 21:00:46  winter
# - fix Prog_Path
#
# Revision 1.1  1999/01/24 20:14:35  winter
# - created from filter_tv_schedule
#
#
